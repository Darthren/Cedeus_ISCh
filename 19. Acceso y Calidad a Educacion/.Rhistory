error = function(e){ print("Error en la consulta. Re-intentando")
; Sys.sleep(10) ;
Consulta_OTP(centroides.coordenadas[g], viaje.tiempo = 15)})
# Incorporar el walkshed resultado en la tabla donde se almacenan los resultados.
# Se incluye la ID del centroide, así como el polígono en geoJSON (texto).
walkshed.table <- rbind(walkshed.table, data.frame("ID" = g, "walkshed.text" = walkshed.text ))
}
# Exportar la tabla resultante en un csv.
write.csv(walkshed.table, paste(walkshed.text.carpeta, ciudad, "_walksheds_text.csv", sep = ""), row.names = F)
}
Consulta_OTP <- function(coordinates, viaje.tiempo = 10, viaje.velocidad = 1.38,
mode = "WALK", outputgeom = "SHED",
otp_rest_url='http://146.155.17.19:17050/otp/routers/chile/'){
# Para no saturar el servidor, se realiza una consulta cada .33 segundos, o 3 consultas por segundo.
Sys.sleep(.33)
# Crear la URL para extraer el walkshed
consulta.parametros = paste('isochroneOld?fromPlace=', coordinates, '&walkTime=',
viaje.tiempo, '&walkSpeed=', viaje.velocidad,'&mode=',
mode, '&toPlace=-33.5846161,-70.5410151&output=', outputgeom, sep = "")
consulta.url <- paste(otp_rest_url, consulta.parametros, sep  = "")
# Extraer el walkshed, el cual viene en formato GeoJSON
walkshed.text <- getURL(consulta.url)
# Contador que define el número de veces que se debe intentar una consulta cuando se encuentran
# geometrías incorrectas.
counter <- 0
# Loop "while". Si el walkshed contiene las palabras "LineString" o "504 Gateway Time-out"
# el request vuelve a ejecutarse hasta 5 veces, con 10 segundos entre cada interación del request.
while((grepl("LineString", walkshed.text) |
grepl("504 Gateway Time-out", walkshed.text)) &
counter <= 5){
print("Resultado inválido. Solicitando de nuevo.")
Sys.sleep(10)
walkshed.text <- getURL(consulta.url)
counter <- counter + 1
}
return(walkshed.text)
}
centroides.carpeta <- "GIS/EE_coords/"
walkshed.text.carpeta <- "GIS/Walksheds GeoJSON_B/"
centroides <- read.csv(paste(centroides.carpeta, "Coords_Educacion.csv", sep = ""))
ciudades <- unique(centroides$Ciudad)
for (c in seq(ciudades)){
# Primero se define la ciudad a trabajar
ciudad <- ciudades[c]
print(paste("Extrayendo datos de:", ciudad))
# Se identifica si existen ciudades que ya se han calculado en la carpeta de los output.
# En caso de ser cierto,s e pasa a la siguiente iteración.
# Esto es para evitar calcular nuevamente una ciudad
if (any(grepl(ciudad, list.files(walkshed.text.carpeta)))){
print(paste(ciudad, "ya posee un archivo asociado a sus datos")); next()}
# Definir los centroides de la ciudad
centroides.ciudad <- centroides[centroides$Ciudad == ciudad,]
# Linea para testear el código. añadir un # cuando se ejecute de forma total.
#centroides.ciudad <- centroides.ciudad[sample(nrow(centroides.ciudad), 10), ]
# Coordenadas de los centroides. Estas serán pasadas a la función Consulta_OTP
centroides.coordenadas <- as.vector(paste(centroides.ciudad[,"lat"], centroides.ciudad[,"lon"], sep = ","))
print("Adquiriendo geometrías")
# Tabla donde se almacenarán los resultados de cada ciudad.
walkshed.table <- data.frame()
for (g in seq(centroides.coordenadas)){
print(paste("Realizando consulta n:", g))
# Se realiza una consulta a OTP. Si esta falla, se muestra un mensaje, se esperan 10 segundos,
# Y se vuelve a intentar.
# NOTA: Debe asegurarse de que todos los pasos anteriores a este se ejecuten de forma correcta.
# Para ello, los archivos y carpetas deben ser nombrados con la convención especificada en el
# Word adjunto.
# Adicionalmente, si el área verde original es mayor a 20000 metros2, el
# tiempo de caminata será de 10 min. De lo contrario, 5 min.
walkshed.text <- tryCatch(Consulta_OTP(centroides.coordenadas[g], viaje.tiempo = 15),
error = function(e){ print("Error en la consulta. Re-intentando")
; Sys.sleep(10) ;
Consulta_OTP(centroides.coordenadas[g], viaje.tiempo = 15)})
# Incorporar el walkshed resultado en la tabla donde se almacenan los resultados.
# Se incluye la ID del centroide, así como el polígono en geoJSON (texto).
walkshed.table <- rbind(walkshed.table, data.frame("ID" = g, "walkshed.text" = walkshed.text ))
}
# Exportar la tabla resultante en un csv.
write.csv(walkshed.table, paste(walkshed.text.carpeta, ciudad, "_walksheds_text.csv", sep = ""), row.names = F)
}
walkshed.text.carpeta <- "GIS/Walksheds GeoJSON_B/"
centroides.carpeta <- "GIS/EE_coords/"
walkshed.shp.carpeta <- "GIS/Walksheds (Manzanas)/UnDissolved"
centroides <- read.csv(paste(centroides.carpeta, "Coords_Educacion.csv", sep = ""))
ciudades <- unique(centroides$Ciudad)
for (c in seq(ciudades)){
# Definir la ciudad
ciudad <- ciudades[c]
# Los centroides de esa ciudad, los cuales poseen el ID de cada manzana.
centroides.ciudad <- centroides[centroides$Ciudad == ciudad,]
# archivo csv que contiene los polígonos en formato GeoJson
walkshed.text <- read.csv(paste(walkshed.text.carpeta, ciudad, "_walksheds_text.csv", sep = ""))
# Una lista donde se almacenará cada polígono
walkshed.shp <- list()
# Loop para transformar a objetos espaciales.
for (i in seq(nrow(walkshed.text))){
print(paste("Polígono número:", i, "de", nrow(walkshed.text)))
# Si el polígono no es válido (java.lang.NullPointerException null), se ignora.
# Estos son casos de manzanas cuyos centroides se encuentran alejados de cualquier red.
if (grepl("java.lang.NullPointerException null", walkshed.text$walkshed.text[i])){print("Datos inválidos. Ignorando"); next()}
# Se ejecuta la función conversor_OTP.
walkshed.poligono <- conversor_OTP(walkshed.text$walkshed.text[i])
# Si el polígono tiene un área 0 (en caso de ser línea, por ejemplo), se ignora.
if (walkshed.poligono@polygons[[1]]@area == 0){ next()}
# Se adjunta un identificador al polígono resultante, para homogolarlo con las manzanas.
walkshed.poligono@data$ID <- centroides.ciudad$ID[i]
# Se adjunta el nombre de la ciudad
walkshed.poligono@data$properties <- ciudad
# Se adjunta el polígono a la lista de polígonos que posteriormente será transformada en un
# objeto único. Algo similar a un "join", o "merge"
walkshed.shp <- append(walkshed.shp, walkshed.poligono)
}
# Consolidación de todos los polígonos como un solo objeto.
walkshed.shp <- do.call(bind, walkshed.shp)
print("Conversión exitosa. Exportando a shp.")
# Exportación de dicho objeto en formato shp.
writeOGR(obj = as(walkshed.shp, "SpatialPolygonsDataFrame" ), dsn = walkshed.shp.carpeta,
layer = paste(ciudad, "_Walksheds_10min (UnDissolved)", sep = ""),
driver = "ESRI Shapefile",overwrite_layer=TRUE)
}
library(geojsonio);library(rjson); library(raster); library(rgdal)
install.packages("geojsonio")
install.packages("rjson")
conversor_OTP <- function(walkshed.texto){
# Algunos objetos vienen con una tercera coordenadas "0.0". Esta línea la elimina.
walkshed.texto <- gsub(",0.0", "", walkshed.texto)
# Transformar el objeto texto a json
walkshed.geojson <- fromJSON(walkshed.texto)
# Dado los problemas que genera esta coordenada Z, algunos polygonos quedan mal clasificados.
# Por ello, implementé un método para abordar los dos tipos de clasificaciones que se producen de forma aleatoria
# Tipo 1: Si el polígono tiene más de dos coordenadas, entonces se procede de forma normal.
if (length(walkshed.geojson$coordinates[[1]]) > 2) {
# Transforma el objeto a geojson, y luego a objeto SpatialPolygonsDataFrame
walkshed.polygon <- geojson_list(walkshed.geojson$coordinates[[1]], geometry = "polygon") %>% geojson_sp
}
else {
# Hay casos donde la API arroja un LineString (ie: el último vertice es distinto al primero)
# Este bloque de "if/else" intenta corregirlo al copiar el primer punto y añadirlo después del último
if (!(walkshed.geojson$coordinates[[1]][1] == walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)]][1] &
walkshed.geojson$coordinates[[1]][2] == walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)]][2])){
walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)+1]] <- walkshed.geojson$coordinates[[1]]
}
# Se imprime un mensaje señalando que se detecto un LinString, y luego se ejecuta
# La conversion de GeoJSON a SpatialPolygonsDataframe
print("LineString detected. Correcting")
walkshed.polygon <- geojson_list(walkshed.geojson$coordinates, geometry = "polygon") %>% geojson_sp
}
return(walkshed.polygon)
}
walkshed.text.carpeta <- "GIS/Walksheds GeoJSON_B/"
centroides.carpeta <- "GIS/EE_coords/"
walkshed.shp.carpeta <- "GIS/Walksheds (Manzanas)/UnDissolved"
centroides <- read.csv(paste(centroides.carpeta, "Coords_Educacion.csv", sep = ""))
ciudades <- unique(centroides$Ciudad)
for (c in seq(ciudades)){
# Definir la ciudad
ciudad <- ciudades[c]
# Los centroides de esa ciudad, los cuales poseen el ID de cada manzana.
centroides.ciudad <- centroides[centroides$Ciudad == ciudad,]
# archivo csv que contiene los polígonos en formato GeoJson
walkshed.text <- read.csv(paste(walkshed.text.carpeta, ciudad, "_walksheds_text.csv", sep = ""))
# Una lista donde se almacenará cada polígono
walkshed.shp <- list()
# Loop para transformar a objetos espaciales.
for (i in seq(nrow(walkshed.text))){
print(paste("Polígono número:", i, "de", nrow(walkshed.text)))
# Si el polígono no es válido (java.lang.NullPointerException null), se ignora.
# Estos son casos de manzanas cuyos centroides se encuentran alejados de cualquier red.
if (grepl("java.lang.NullPointerException null", walkshed.text$walkshed.text[i])){print("Datos inválidos. Ignorando"); next()}
# Se ejecuta la función conversor_OTP.
walkshed.poligono <- conversor_OTP(walkshed.text$walkshed.text[i])
# Si el polígono tiene un área 0 (en caso de ser línea, por ejemplo), se ignora.
if (walkshed.poligono@polygons[[1]]@area == 0){ next()}
# Se adjunta un identificador al polígono resultante, para homogolarlo con las manzanas.
walkshed.poligono@data$ID <- centroides.ciudad$ID[i]
# Se adjunta el nombre de la ciudad
walkshed.poligono@data$properties <- ciudad
# Se adjunta el polígono a la lista de polígonos que posteriormente será transformada en un
# objeto único. Algo similar a un "join", o "merge"
walkshed.shp <- append(walkshed.shp, walkshed.poligono)
}
# Consolidación de todos los polígonos como un solo objeto.
walkshed.shp <- do.call(bind, walkshed.shp)
print("Conversión exitosa. Exportando a shp.")
# Exportación de dicho objeto en formato shp.
writeOGR(obj = as(walkshed.shp, "SpatialPolygonsDataFrame" ), dsn = walkshed.shp.carpeta,
layer = paste(ciudad, "_Walksheds_10min (UnDissolved)", sep = ""),
driver = "ESRI Shapefile",overwrite_layer=TRUE)
}
install.packages("jsonlite")
library(geojsonio);library(rjson); library(raster); library(rgdal); library(jsonlite)
conversor_OTP <- function(walkshed.texto){
# Algunos objetos vienen con una tercera coordenadas "0.0". Esta línea la elimina.
walkshed.texto <- gsub(",0.0", "", walkshed.texto)
# Transformar el objeto texto a json
walkshed.geojson <- fromJSON(walkshed.texto)
# Dado los problemas que genera esta coordenada Z, algunos polygonos quedan mal clasificados.
# Por ello, implementé un método para abordar los dos tipos de clasificaciones que se producen de forma aleatoria
# Tipo 1: Si el polígono tiene más de dos coordenadas, entonces se procede de forma normal.
if (length(walkshed.geojson$coordinates[[1]]) > 2) {
# Transforma el objeto a geojson, y luego a objeto SpatialPolygonsDataFrame
walkshed.polygon <- geojson_list(walkshed.geojson$coordinates[[1]], geometry = "polygon") %>% geojson_sp
}
else {
# Hay casos donde la API arroja un LineString (ie: el último vertice es distinto al primero)
# Este bloque de "if/else" intenta corregirlo al copiar el primer punto y añadirlo después del último
if (!(walkshed.geojson$coordinates[[1]][1] == walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)]][1] &
walkshed.geojson$coordinates[[1]][2] == walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)]][2])){
walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)+1]] <- walkshed.geojson$coordinates[[1]]
}
# Se imprime un mensaje señalando que se detecto un LinString, y luego se ejecuta
# La conversion de GeoJSON a SpatialPolygonsDataframe
print("LineString detected. Correcting")
walkshed.polygon <- geojson_list(walkshed.geojson$coordinates, geometry = "polygon") %>% geojson_sp
}
return(walkshed.polygon)
}
walkshed.text.carpeta <- "GIS/Walksheds GeoJSON_B/"
centroides.carpeta <- "GIS/EE_coords/"
walkshed.shp.carpeta <- "GIS/Walksheds (Manzanas)/UnDissolved"
centroides <- read.csv(paste(centroides.carpeta, "Coords_Educacion.csv", sep = ""))
ciudades <- unique(centroides$Ciudad)
for (c in seq(ciudades)){
# Definir la ciudad
ciudad <- ciudades[c]
# Los centroides de esa ciudad, los cuales poseen el ID de cada manzana.
centroides.ciudad <- centroides[centroides$Ciudad == ciudad,]
# archivo csv que contiene los polígonos en formato GeoJson
walkshed.text <- read.csv(paste(walkshed.text.carpeta, ciudad, "_walksheds_text.csv", sep = ""))
# Una lista donde se almacenará cada polígono
walkshed.shp <- list()
# Loop para transformar a objetos espaciales.
for (i in seq(nrow(walkshed.text))){
print(paste("Polígono número:", i, "de", nrow(walkshed.text)))
# Si el polígono no es válido (java.lang.NullPointerException null), se ignora.
# Estos son casos de manzanas cuyos centroides se encuentran alejados de cualquier red.
if (grepl("java.lang.NullPointerException null", walkshed.text$walkshed.text[i])){print("Datos inválidos. Ignorando"); next()}
# Se ejecuta la función conversor_OTP.
walkshed.poligono <- conversor_OTP(walkshed.text$walkshed.text[i])
# Si el polígono tiene un área 0 (en caso de ser línea, por ejemplo), se ignora.
if (walkshed.poligono@polygons[[1]]@area == 0){ next()}
# Se adjunta un identificador al polígono resultante, para homogolarlo con las manzanas.
walkshed.poligono@data$ID <- centroides.ciudad$ID[i]
# Se adjunta el nombre de la ciudad
walkshed.poligono@data$properties <- ciudad
# Se adjunta el polígono a la lista de polígonos que posteriormente será transformada en un
# objeto único. Algo similar a un "join", o "merge"
walkshed.shp <- append(walkshed.shp, walkshed.poligono)
}
# Consolidación de todos los polígonos como un solo objeto.
walkshed.shp <- do.call(bind, walkshed.shp)
print("Conversión exitosa. Exportando a shp.")
# Exportación de dicho objeto en formato shp.
writeOGR(obj = as(walkshed.shp, "SpatialPolygonsDataFrame" ), dsn = walkshed.shp.carpeta,
layer = paste(ciudad, "_Walksheds_10min (UnDissolved)", sep = ""),
driver = "ESRI Shapefile",overwrite_layer=TRUE)
}
library(raster)
install.packages("raster")
install.packages("rjson")
install.packages(rgdal)
install.packages("rgdal")
library(geojsonio);library(rjson); library(raster); library(rgdal); library(jsonlite)
conversor_OTP <- function(walkshed.texto){
# Algunos objetos vienen con una tercera coordenadas "0.0". Esta línea la elimina.
walkshed.texto <- gsub(",0.0", "", walkshed.texto)
# Transformar el objeto texto a json
walkshed.geojson <- fromJSON(walkshed.texto)
# Dado los problemas que genera esta coordenada Z, algunos polygonos quedan mal clasificados.
# Por ello, implementé un método para abordar los dos tipos de clasificaciones que se producen de forma aleatoria
# Tipo 1: Si el polígono tiene más de dos coordenadas, entonces se procede de forma normal.
if (length(walkshed.geojson$coordinates[[1]]) > 2) {
# Transforma el objeto a geojson, y luego a objeto SpatialPolygonsDataFrame
walkshed.polygon <- geojson_list(walkshed.geojson$coordinates[[1]], geometry = "polygon") %>% geojson_sp
}
else {
# Hay casos donde la API arroja un LineString (ie: el último vertice es distinto al primero)
# Este bloque de "if/else" intenta corregirlo al copiar el primer punto y añadirlo después del último
if (!(walkshed.geojson$coordinates[[1]][1] == walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)]][1] &
walkshed.geojson$coordinates[[1]][2] == walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)]][2])){
walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)+1]] <- walkshed.geojson$coordinates[[1]]
}
# Se imprime un mensaje señalando que se detecto un LinString, y luego se ejecuta
# La conversion de GeoJSON a SpatialPolygonsDataframe
print("LineString detected. Correcting")
walkshed.polygon <- geojson_list(walkshed.geojson$coordinates, geometry = "polygon") %>% geojson_sp
}
return(walkshed.polygon)
}
walkshed.text.carpeta <- "GIS/Walksheds GeoJSON_B/"
centroides.carpeta <- "GIS/EE_coords/"
walkshed.shp.carpeta <- "GIS/Walksheds (Manzanas)/UnDissolved"
centroides <- read.csv(paste(centroides.carpeta, "Coords_Educacion.csv", sep = ""))
ciudades <- unique(centroides$Ciudad)
for (c in seq(ciudades)){
# Definir la ciudad
ciudad <- ciudades[c]
# Los centroides de esa ciudad, los cuales poseen el ID de cada manzana.
centroides.ciudad <- centroides[centroides$Ciudad == ciudad,]
# archivo csv que contiene los polígonos en formato GeoJson
walkshed.text <- read.csv(paste(walkshed.text.carpeta, ciudad, "_walksheds_text.csv", sep = ""))
# Una lista donde se almacenará cada polígono
walkshed.shp <- list()
# Loop para transformar a objetos espaciales.
for (i in seq(nrow(walkshed.text))){
print(paste("Polígono número:", i, "de", nrow(walkshed.text)))
# Si el polígono no es válido (java.lang.NullPointerException null), se ignora.
# Estos son casos de manzanas cuyos centroides se encuentran alejados de cualquier red.
if (grepl("java.lang.NullPointerException null", walkshed.text$walkshed.text[i])){print("Datos inválidos. Ignorando"); next()}
# Se ejecuta la función conversor_OTP.
walkshed.poligono <- conversor_OTP(walkshed.text$walkshed.text[i])
# Si el polígono tiene un área 0 (en caso de ser línea, por ejemplo), se ignora.
if (walkshed.poligono@polygons[[1]]@area == 0){ next()}
# Se adjunta un identificador al polígono resultante, para homogolarlo con las manzanas.
walkshed.poligono@data$ID <- centroides.ciudad$ID[i]
# Se adjunta el nombre de la ciudad
walkshed.poligono@data$properties <- ciudad
# Se adjunta el polígono a la lista de polígonos que posteriormente será transformada en un
# objeto único. Algo similar a un "join", o "merge"
walkshed.shp <- append(walkshed.shp, walkshed.poligono)
}
# Consolidación de todos los polígonos como un solo objeto.
walkshed.shp <- do.call(bind, walkshed.shp)
print("Conversión exitosa. Exportando a shp.")
# Exportación de dicho objeto en formato shp.
writeOGR(obj = as(walkshed.shp, "SpatialPolygonsDataFrame" ), dsn = walkshed.shp.carpeta,
layer = paste(ciudad, "_Walksheds_10min (UnDissolved)", sep = ""),
driver = "ESRI Shapefile",overwrite_layer=TRUE)
}
library(geojsonio);library(rjson); library(raster); library(rgdal); library(jsonlite)
conversor_OTP <- function(walkshed.texto){
# Algunos objetos vienen con una tercera coordenadas "0.0". Esta línea la elimina.
walkshed.texto <- gsub(",0.0", "", walkshed.texto)
# Transformar el objeto texto a json
walkshed.geojson <- fromJSON(walkshed.texto)
# Dado los problemas que genera esta coordenada Z, algunos polygonos quedan mal clasificados.
# Por ello, implementé un método para abordar los dos tipos de clasificaciones que se producen de forma aleatoria
# Tipo 1: Si el polígono tiene más de dos coordenadas, entonces se procede de forma normal.
if (length(walkshed.geojson$coordinates[[1]]) > 2) {
# Transforma el objeto a geojson, y luego a objeto SpatialPolygonsDataFrame
walkshed.polygon <- geojson_list(walkshed.geojson$coordinates[[1]], geometry = "polygon") %>% geojson_sp
}
else {
# Hay casos donde la API arroja un LineString (ie: el último vertice es distinto al primero)
# Este bloque de "if/else" intenta corregirlo al copiar el primer punto y añadirlo después del último
if (!(walkshed.geojson$coordinates[[1]][1] == walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)]][1] &
walkshed.geojson$coordinates[[1]][2] == walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)]][2])){
walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)+1]] <- walkshed.geojson$coordinates[[1]]
}
# Se imprime un mensaje señalando que se detecto un LinString, y luego se ejecuta
# La conversion de GeoJSON a SpatialPolygonsDataframe
print("LineString detected. Correcting")
walkshed.polygon <- geojson_list(walkshed.geojson$coordinates, geometry = "polygon") %>% geojson_sp
}
return(walkshed.polygon)
}
walkshed.text.carpeta <- "GIS/Walksheds GeoJSON_B/"
centroides.carpeta <- "GIS/EE_coords/"
walkshed.shp.carpeta <- "GIS/Walksheds (Manzanas)/UnDissolved"
centroides <- read.csv(paste(centroides.carpeta, "Coords_Educacion.csv", sep = ""))
ciudades <- unique(centroides$Ciudad)
for (c in seq(ciudades)){
# Definir la ciudad
ciudad <- ciudades[c]
# Los centroides de esa ciudad, los cuales poseen el ID de cada manzana.
centroides.ciudad <- centroides[centroides$Ciudad == ciudad,]
# archivo csv que contiene los polígonos en formato GeoJson
walkshed.text <- read.csv(paste(walkshed.text.carpeta, ciudad, "_walksheds_text.csv", sep = ""))
# Una lista donde se almacenará cada polígono
walkshed.shp <- list()
# Loop para transformar a objetos espaciales.
for (i in seq(nrow(walkshed.text))){
print(paste("Polígono número:", i, "de", nrow(walkshed.text)))
# Si el polígono no es válido (java.lang.NullPointerException null), se ignora.
# Estos son casos de manzanas cuyos centroides se encuentran alejados de cualquier red.
if (grepl("java.lang.NullPointerException null", walkshed.text$walkshed.text[i])){print("Datos inválidos. Ignorando"); next()}
# Se ejecuta la función conversor_OTP.
walkshed.poligono <- conversor_OTP(walkshed.text$walkshed.text[i])
# Si el polígono tiene un área 0 (en caso de ser línea, por ejemplo), se ignora.
if (walkshed.poligono@polygons[[1]]@area == 0){ next()}
# Se adjunta un identificador al polígono resultante, para homogolarlo con las manzanas.
walkshed.poligono@data$ID <- centroides.ciudad$ID[i]
# Se adjunta el nombre de la ciudad
walkshed.poligono@data$properties <- ciudad
# Se adjunta el polígono a la lista de polígonos que posteriormente será transformada en un
# objeto único. Algo similar a un "join", o "merge"
walkshed.shp <- append(walkshed.shp, walkshed.poligono)
}
# Consolidación de todos los polígonos como un solo objeto.
walkshed.shp <- do.call(bind, walkshed.shp)
print("Conversión exitosa. Exportando a shp.")
# Exportación de dicho objeto en formato shp.
writeOGR(obj = as(walkshed.shp, "SpatialPolygonsDataFrame" ), dsn = walkshed.shp.carpeta,
layer = paste(ciudad, "_Walksheds_10min (UnDissolved)", sep = ""),
driver = "ESRI Shapefile",overwrite_layer=TRUE)
}
centroides.ciudad
walkshed.text
detach(package::jsonlite, unload = T)
detach("package::jsonlite", unload = T)
detach("package:jsonlite", unload = T)
library(geojsonio);library(rjson); library(raster); library(rgdal)
conversor_OTP <- function(walkshed.texto){
# Algunos objetos vienen con una tercera coordenadas "0.0". Esta línea la elimina.
walkshed.texto <- gsub(",0.0", "", walkshed.texto)
# Transformar el objeto texto a json
walkshed.geojson <- fromJSON(walkshed.texto)
# Dado los problemas que genera esta coordenada Z, algunos polygonos quedan mal clasificados.
# Por ello, implementé un método para abordar los dos tipos de clasificaciones que se producen de forma aleatoria
# Tipo 1: Si el polígono tiene más de dos coordenadas, entonces se procede de forma normal.
if (length(walkshed.geojson$coordinates[[1]]) > 2) {
# Transforma el objeto a geojson, y luego a objeto SpatialPolygonsDataFrame
walkshed.polygon <- geojson_list(walkshed.geojson$coordinates[[1]], geometry = "polygon") %>% geojson_sp
}
else {
# Hay casos donde la API arroja un LineString (ie: el último vertice es distinto al primero)
# Este bloque de "if/else" intenta corregirlo al copiar el primer punto y añadirlo después del último
if (!(walkshed.geojson$coordinates[[1]][1] == walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)]][1] &
walkshed.geojson$coordinates[[1]][2] == walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)]][2])){
walkshed.geojson$coordinates[[length(walkshed.geojson$coordinates)+1]] <- walkshed.geojson$coordinates[[1]]
}
# Se imprime un mensaje señalando que se detecto un LinString, y luego se ejecuta
# La conversion de GeoJSON a SpatialPolygonsDataframe
print("LineString detected. Correcting")
walkshed.polygon <- geojson_list(walkshed.geojson$coordinates, geometry = "polygon") %>% geojson_sp
}
return(walkshed.polygon)
}
walkshed.text.carpeta <- "GIS/Walksheds GeoJSON_B/"
centroides.carpeta <- "GIS/EE_coords/"
walkshed.shp.carpeta <- "GIS/Walksheds (Manzanas)/UnDissolved"
centroides <- read.csv(paste(centroides.carpeta, "Coords_Educacion.csv", sep = ""))
ciudades <- unique(centroides$Ciudad)
for (c in seq(ciudades)){
# Definir la ciudad
ciudad <- ciudades[c]
# Los centroides de esa ciudad, los cuales poseen el ID de cada manzana.
centroides.ciudad <- centroides[centroides$Ciudad == ciudad,]
# archivo csv que contiene los polígonos en formato GeoJson
walkshed.text <- read.csv(paste(walkshed.text.carpeta, ciudad, "_walksheds_text.csv", sep = ""))
# Una lista donde se almacenará cada polígono
walkshed.shp <- list()
# Loop para transformar a objetos espaciales.
for (i in seq(nrow(walkshed.text))){
print(paste("Polígono número:", i, "de", nrow(walkshed.text)))
# Si el polígono no es válido (java.lang.NullPointerException null), se ignora.
# Estos son casos de manzanas cuyos centroides se encuentran alejados de cualquier red.
if (grepl("java.lang.NullPointerException null", walkshed.text$walkshed.text[i])){print("Datos inválidos. Ignorando"); next()}
# Se ejecuta la función conversor_OTP.
walkshed.poligono <- conversor_OTP(walkshed.text$walkshed.text[i])
# Si el polígono tiene un área 0 (en caso de ser línea, por ejemplo), se ignora.
if (walkshed.poligono@polygons[[1]]@area == 0){ next()}
# Se adjunta un identificador al polígono resultante, para homogolarlo con las manzanas.
walkshed.poligono@data$ID <- centroides.ciudad$ID[i]
# Se adjunta el nombre de la ciudad
walkshed.poligono@data$properties <- ciudad
# Se adjunta el polígono a la lista de polígonos que posteriormente será transformada en un
# objeto único. Algo similar a un "join", o "merge"
walkshed.shp <- append(walkshed.shp, walkshed.poligono)
}
# Consolidación de todos los polígonos como un solo objeto.
walkshed.shp <- do.call(bind, walkshed.shp)
print("Conversión exitosa. Exportando a shp.")
# Exportación de dicho objeto en formato shp.
writeOGR(obj = as(walkshed.shp, "SpatialPolygonsDataFrame" ), dsn = walkshed.shp.carpeta,
layer = paste(ciudad, "_Walksheds_10min (UnDissolved)", sep = ""),
driver = "ESRI Shapefile",overwrite_layer=TRUE)
}
writeOGR(obj = as(walkshed.shp, "SpatialPolygonsDataFrame" ), dsn = walkshed.shp.carpeta,
layer = paste(ciudad, "_Walksheds_10min (UnDissolved)", sep = ""),
driver = "ESRI Shapefile",overwrite_layer=TRUE)
walkshed.shp.carpeta <- "GIS/Walksheds (Manzanas)/UnDissolved"
writeOGR(obj = as(walkshed.shp, "SpatialPolygonsDataFrame" ), dsn = walkshed.shp.carpeta,
layer = paste(ciudad, "_Walksheds_10min (UnDissolved)", sep = ""),
driver = "ESRI Shapefile",overwrite_layer=TRUE)
writeOGR(obj = as(walkshed.shp, "SpatialPolygonsDataFrame" ), dsn = walkshed.shp.carpeta,
layer = paste(ciudad, "_Walksheds_10min (UnDissolved)", sep = ""),
driver = "ESRI Shapefile",overwrite_layer=TRUE)
for (c in seq(ciudades)){
# Definir la ciudad
ciudad <- ciudades[c]
# Los centroides de esa ciudad, los cuales poseen el ID de cada manzana.
centroides.ciudad <- centroides[centroides$Ciudad == ciudad,]
# archivo csv que contiene los polígonos en formato GeoJson
walkshed.text <- read.csv(paste(walkshed.text.carpeta, ciudad, "_walksheds_text.csv", sep = ""))
# Una lista donde se almacenará cada polígono
walkshed.shp <- list()
# Loop para transformar a objetos espaciales.
for (i in seq(nrow(walkshed.text))){
print(paste("Polígono número:", i, "de", nrow(walkshed.text)))
# Si el polígono no es válido (java.lang.NullPointerException null), se ignora.
# Estos son casos de manzanas cuyos centroides se encuentran alejados de cualquier red.
if (grepl("java.lang.NullPointerException null", walkshed.text$walkshed.text[i])){print("Datos inválidos. Ignorando"); next()}
# Se ejecuta la función conversor_OTP.
walkshed.poligono <- conversor_OTP(walkshed.text$walkshed.text[i])
# Si el polígono tiene un área 0 (en caso de ser línea, por ejemplo), se ignora.
if (walkshed.poligono@polygons[[1]]@area == 0){ next()}
# Se adjunta un identificador al polígono resultante, para homogolarlo con las manzanas.
walkshed.poligono@data$ID <- centroides.ciudad$ID[i]
# Se adjunta el nombre de la ciudad
walkshed.poligono@data$properties <- ciudad
# Se adjunta el polígono a la lista de polígonos que posteriormente será transformada en un
# objeto único. Algo similar a un "join", o "merge"
walkshed.shp <- append(walkshed.shp, walkshed.poligono)
}
# Consolidación de todos los polígonos como un solo objeto.
walkshed.shp <- do.call(bind, walkshed.shp)
print("Conversión exitosa. Exportando a shp.")
# Exportación de dicho objeto en formato shp.
writeOGR(obj = as(walkshed.shp, "SpatialPolygonsDataFrame" ), dsn = walkshed.shp.carpeta,
layer = paste(ciudad, "_Walksheds_10min (UnDissolved)", sep = ""),
driver = "ESRI Shapefile",overwrite_layer=TRUE)
}
